// Copyright 2020 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

// (Re-)generated by schema tool
// >>>> DO NOT CHANGE THIS FILE! <<<<
// Change the json schema instead

#![allow(dead_code)]
#![allow(unused_imports)]

use wasmlib::*;

#[derive(Clone)]
pub struct Claim {
    pub claimer              : ScAgentID, 
    pub deposit              : u64, 
    pub id                   : ScHash, 
    pub plant_id             : ScHash, 
    pub recorded_water_level : i32, 
    pub timestamp            : u64, 
}

impl Claim {
    pub fn from_bytes(bytes: &[u8]) -> Claim {
        let mut dec = WasmDecoder::new(bytes);
        Claim {
            claimer              : agent_id_decode(&mut dec),
            deposit              : uint64_decode(&mut dec),
            id                   : hash_decode(&mut dec),
            plant_id             : hash_decode(&mut dec),
            recorded_water_level : int32_decode(&mut dec),
            timestamp            : uint64_decode(&mut dec),
        }
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        let mut enc = WasmEncoder::new();
		agent_id_encode(&mut enc, &self.claimer);
		uint64_encode(&mut enc, self.deposit);
		hash_encode(&mut enc, &self.id);
		hash_encode(&mut enc, &self.plant_id);
		int32_encode(&mut enc, self.recorded_water_level);
		uint64_encode(&mut enc, self.timestamp);
        enc.buf()
    }
}

#[derive(Clone)]
pub struct ImmutableClaim {
    pub(crate) proxy: Proxy,
}

impl ImmutableClaim {
    pub fn exists(&self) -> bool {
        self.proxy.exists()
    }

    pub fn value(&self) -> Claim {
        Claim::from_bytes(&self.proxy.get())
    }
}

#[derive(Clone)]
pub struct MutableClaim {
    pub(crate) proxy: Proxy,
}

impl MutableClaim {
    pub fn delete(&self) {
        self.proxy.delete();
    }

    pub fn exists(&self) -> bool {
        self.proxy.exists()
    }

    pub fn set_value(&self, value: &Claim) {
        self.proxy.set(&value.to_bytes());
    }

    pub fn value(&self) -> Claim {
        Claim::from_bytes(&self.proxy.get())
    }
}

#[derive(Clone)]
pub struct Plant {
    pub active          : bool, 
    pub active_reason   : u32,  // 0 -> default, 1 -> owner deactivated, 2 -> weather deactivated, 3 -> owner deactivated
    pub claim_id        : ScHash,  // used to index claims (for scalability purposes)
    pub claimed         : bool,  // whether plant has been claimed
    pub covered         : bool, 
    pub current_water   : i32,  // current level of water
    pub description     : String,  // general description of plant
    pub funds           : u64, 
    pub id              : ScHash, 
    pub lattitude       : String,  // geolocation structs don't work WOW
    pub longitude       : String, 
    pub manufacturer    : ScAgentID,  // manufacturer wallet for payment
    pub name            : String, 
    pub owner           : ScAgentID,  // owner of plant token
    pub reward          : u64,  // the reward given for watering the plant
    pub water_target    : i32,  // level of water
    pub water_threshold : i32,  // min. level of water to start watering
}

impl Plant {
    pub fn from_bytes(bytes: &[u8]) -> Plant {
        let mut dec = WasmDecoder::new(bytes);
        Plant {
            active          : bool_decode(&mut dec),
            active_reason   : uint32_decode(&mut dec),
            claim_id        : hash_decode(&mut dec),
            claimed         : bool_decode(&mut dec),
            covered         : bool_decode(&mut dec),
            current_water   : int32_decode(&mut dec),
            description     : string_decode(&mut dec),
            funds           : uint64_decode(&mut dec),
            id              : hash_decode(&mut dec),
            lattitude       : string_decode(&mut dec),
            longitude       : string_decode(&mut dec),
            manufacturer    : agent_id_decode(&mut dec),
            name            : string_decode(&mut dec),
            owner           : agent_id_decode(&mut dec),
            reward          : uint64_decode(&mut dec),
            water_target    : int32_decode(&mut dec),
            water_threshold : int32_decode(&mut dec),
        }
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        let mut enc = WasmEncoder::new();
		bool_encode(&mut enc, self.active);
		uint32_encode(&mut enc, self.active_reason);
		hash_encode(&mut enc, &self.claim_id);
		bool_encode(&mut enc, self.claimed);
		bool_encode(&mut enc, self.covered);
		int32_encode(&mut enc, self.current_water);
		string_encode(&mut enc, &self.description);
		uint64_encode(&mut enc, self.funds);
		hash_encode(&mut enc, &self.id);
		string_encode(&mut enc, &self.lattitude);
		string_encode(&mut enc, &self.longitude);
		agent_id_encode(&mut enc, &self.manufacturer);
		string_encode(&mut enc, &self.name);
		agent_id_encode(&mut enc, &self.owner);
		uint64_encode(&mut enc, self.reward);
		int32_encode(&mut enc, self.water_target);
		int32_encode(&mut enc, self.water_threshold);
        enc.buf()
    }
}

#[derive(Clone)]
pub struct ImmutablePlant {
    pub(crate) proxy: Proxy,
}

impl ImmutablePlant {
    pub fn exists(&self) -> bool {
        self.proxy.exists()
    }

    pub fn value(&self) -> Plant {
        Plant::from_bytes(&self.proxy.get())
    }
}

#[derive(Clone)]
pub struct MutablePlant {
    pub(crate) proxy: Proxy,
}

impl MutablePlant {
    pub fn delete(&self) {
        self.proxy.delete();
    }

    pub fn exists(&self) -> bool {
        self.proxy.exists()
    }

    pub fn set_value(&self, value: &Plant) {
        self.proxy.set(&value.to_bytes());
    }

    pub fn value(&self) -> Plant {
        Plant::from_bytes(&self.proxy.get())
    }
}
